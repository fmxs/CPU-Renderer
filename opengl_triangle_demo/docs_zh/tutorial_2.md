# OpenGL 三角形 Demo 实践教程：构建一个会呼吸的渐变三角形

## 五、工程文件准备

让我们思考一下把大象放进冰箱需要几步：

打开冰箱、把大象放进去、关上冰箱。

如果你是零基础，要想画出一个三角形，你会怎么做呢？

你可能也会把事情拆成三步走：
打开窗口、绘制三角形、关闭窗口。

实际上，要画出三角形，还需要一些更详细的步骤，下面给出原因：

---

### 扩充冰箱里的大象步骤-1

OpenGL 仅仅是一个接口规范，不同系统把它的实现藏在了不同的角落。
要想真正用上这些功能，我们必须先找到它们的“门牌号”，也就是函数指针。

为了不用自己一间间去找门，我们需要引入一本“字典”，它会告诉我们每个函数的门牌号在哪。
这个字典叫做 **GLAD**。文件名称是 `glad.c` / `glad.h` + `khrplatform.h`。在上一节教程里，我们介绍了如何下载 GLAD 对应的压缩包 `glad.zip`。

**到现在为止，文件准备步骤会扩充为：**
导入字典 → 打开窗口 → 绘制三角形 → 关闭窗口

---

### 扩充冰箱里的大象步骤-2

为了在不同的平台上能正确构建工程，我们还需要导入一个构建工程的配置文件，这个文件叫做 **CMakeLists.txt**。

**到现在为止，文件准备步骤会扩充为：**
导入字典 → 导入工程配置 → 打开窗口 → 绘制三角形 → 关闭窗口

---

### 扩充冰箱里的大象步骤-3

接下来，我们不仅仅是想画一个三角形，而是画一个彩色的、带呼吸态的三角形。

为了解决这个问题，我们需要编写 **shader**，换句话说，我们需要自定义顶点着色器和片元着色器。这个教程里的着色器非常简单，仅仅只有十行左右的代码。

**到现在为止，文件准备步骤会扩充为：**
导入字典 → 导入工程配置 → 编写 shader → 打开窗口 → 绘制三角形 → 关闭窗口

> 注意：目前介绍的是文件准备顺序。如果是在程序运行时，必须先打开窗口、再处理 shader。这部分内容我们将在之后进行讲述。

---

### 扩充冰箱里的大象步骤-4

接下来，我们需要考虑数据结构问题。

在二维坐标系中，一个三角形可以使用 A(x1,y1)、B(x2,y2)、C(x3,y3) 三个顶点来表示。
在计算机中，一个三角形也可以用这样的结构存储：

```text
{ x1 | y1 | x2 | y2 | x3 | y3 }
```

我们可以声明一个对象 `object`，就变成了：

```text
object = { x1 | y1 | x2 | y2 | x3 | y3 }，
```

`object` 在 CPU 里是数组，当我们将三角形的数据上传给 GPU 时，GPU 里将有一个缓冲对象存储这些值。这个缓冲对象叫做 **VBO (Vertex Buffer Object)** —— 顶点缓冲对象。

> 注意：这里的 `object` 是为了方便理解，本质上 VBO 是 GPU 内存里的缓冲对象，不是一个等于 `{x1, y1, ...}` 的 object。

早期（OpenGL 1.x/2.x）时，得用 `glBegin()/glEnd()` 一个个塞顶点，CPU → GPU 频繁传输，效率惨不忍睹。
自从 VBO 出现后，数据可以一次性丢到 GPU 里，画的时候直接用 GPU 里的现成数据，快得飞起。

必须先准备好 VBO，再绘制三角形，否则 GPU 就没有数据可画。

**到现在为止，文件准备步骤会扩充为：**
导入字典 → 导入工程配置 → 编写 shader → 打开窗口 → 设置 VBO → 绘制三角形 → 关闭窗口

---

### 扩充冰箱里的大象步骤-5

有了数据后，我们还需要考虑数据的读取问题。

还是以之前的 `object` 为例：

```text
object = { x1 | y1 | x2 | y2 | x3 | y3 }，
```

GPU 并不知道这里的值是怎么排列的，我们需要告诉 GPU，顶点 A 需要取出第 0 位和第 1 位，GPU 才能知道。

我们可以声明一个 `array`，记录 `object` 里的结构：

```text
array = { 0,2 } # 顶点A，从第0位开始，长度2
array = { 0,2 | 2,2 } # 顶点B，从第2位开始，长度2
array = { 0,2 | 2,2 | 4,2 } # 顶点C，从第4位开始，长度2
```

可以观察到规律：
假设要取出第 n 个顶点的数据，则是从第 2n 位开始，长度为 2。

所以 `array` 的表示方式可以进一步被压缩：

```text
array = { 2n, 2 } # 顶点n的数据，从第2n位开始取，长度2
```

`array` 是一个配置表，它记录了如何读取 `object`（顶点缓冲对象）中的数据，比如：

* 偏移量 —— 从第几位开始读
* 步长 —— 每次读多少长度的数据
* 数据类型 —— int 还是 float
* 目标 —— 读出来的数据赋值给哪个对象
* 是否启用 —— 决定某个对象要不要使用（没启用的话，即使有数据 GPU 也不会用）

我们把这个 `array` 叫做 **VAO (Vertex Array Object)** —— 顶点数组对象。

如果没有 VAO，GPU 就不知道怎么读取数据，它是绘制三角形过程里必不可少的一部分。

> 注意：这里用 `array` 类比只是方便理解，本质上 VAO 存的是属性配置，而不是具体的数据索引表。

**到现在为止，文件准备步骤会扩充为：**
导入字典 → 导入工程配置 → 编写 shader → 打开窗口 → 设置 VBO/VAO → 绘制三角形 → 关闭窗口

---

### 扩充冰箱里的大象步骤-6

Shader 编写完后，并不能在窗口里直接使用。
这是因为它目前只能够被人阅读，而计算机需要的是可执行的本地代码。

因此我们还需要对 Shader 做 **编译和链接**。

而且编译和链接的时序也很重要，需要放在打开窗口之后。这是因为编译和链接依赖程序保存的一些资源（上下文）。

> 不同平台在上下文创建上有细微差异，例如 macOS 需要额外指定 `GLFW_OPENGL_FORWARD_COMPAT`，请参考平台文档（platform\_mac.md / platform\_win.md / platform\_linux.md）。

**到现在为止，文件准备步骤会扩充为：**
导入字典 → 导入工程配置 → 编写 shader → 打开窗口 → 设置 VBO/VAO → 编译和链接 shader → 绘制三角形 → 关闭窗口

---

## 六、文件准备步骤总结

1. 导入字典：`gl.c`, `gl.h`, `khrplatform.h` （参考`platform_xxx.md`）
2. 导入工程配置：`CMakeLists.txt`（参考`platform_xxx.md`）
3. 编写shader1：顶点着色器 `triangle.vert`
4. 编写shader2：片元着色器 `triangle.frag`
5. 编写 `main.cpp`

   * 5-1 打开窗口：创建窗口，准备上下文
   * 5-2 设置VBO/VAO：准备GPU所需数据
   * 5-3 编译和链接shader：编译并链接顶点着色器、片元着色器
   * 5-4 绘制三角形：编写循环，每帧刷新三角形的颜色
   * 5-5 关闭窗口：清理资源
6. 构建工程与运行：构建的工程将存放在build文件夹内

> 平台特定的差异步骤请参考对应的 `platform_xxx.md` 文档。
