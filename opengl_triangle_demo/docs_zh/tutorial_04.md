# OpenGL 三角形 Demo 实践教程：构建一个会呼吸的渐变三角形

## 4-1、片元着色器（triangle.frag）

在前一节里，我们介绍了 **顶点着色器**：它负责告诉 GPU —— 三角形的三个点在屏幕上的位置，以及每个点的颜色。  
但是光有顶点可不行啊，中间那一大片像素谁来管？这时候就轮到 **片元着色器 (Fragment Shader)** 出场了。

---

### 1. 什么是片元着色器？

想象一下：  
- 顶点着色器就像给三角形的三个角贴上了“彩色便利贴”；  
- 那 GPU 怎么知道三角形里面的其他像素要涂成什么颜色？  

答案是：**GPU 会自动在三个点之间做插值，把每个像素点（fragment）的颜色算出来。**  
但最终的颜色能不能加点效果、是不是直接用插值结果，就由 **片元着色器** 决定。

一句话：  
👉 **片元着色器就是“像素级化妆师”**，它给屏幕上的每一个像素点上妆。

---

### 2. 我们的片元着色器代码

在 `shaders/triangle.frag` 里写下以下代码：

```glsl
#version 150 core

in vec3 vColor;          // 从顶点着色器传下来的颜色
uniform float u_time;    // 从CPU传进来的时间变量
out vec4 FragColor;      // 最终输出到屏幕的颜色

void main() {
    // 呼吸效果：利用正弦函数周期性变化，让颜色亮度像呼吸一样起伏
    float pulse = abs(sin(u_time));
    FragColor = vec4(vColor * pulse, 1.0);
}
````

---

### 3. 代码逐行解释

* `in vec3 vColor;`
  顶点着色器会把每个点的颜色往这里塞，GPU 自动帮你插值。比如顶点是红、绿、蓝三色，中间的像素会自然变成渐变色。

* `uniform float u_time;`
  这是我们从 CPU 传进来的“时间变量”，随着帧数增加不断变化。
  它就像一个节拍器，告诉片元着色器现在是“呼”还是“吸”。

* `out vec4 FragColor;`
  每个像素最终的颜色输出到这里。vec4 四个分量分别是 R、G、B、A（红、绿、蓝、透明度）。

* `float pulse = abs(sin(u_time));`
  `sin` 函数会在 \[-1, 1] 之间来回跳。取绝对值之后，就变成 \[0, 1] 的“呼吸曲线”。
  随着时间推进，这个数值会周期性变大变小。

* `FragColor = vec4(vColor * pulse, 1.0);`
  把顶点颜色乘上 `pulse`，就能实现“亮-暗-亮-暗”的效果，看起来就像三角形在呼吸。

---

### 4. 为什么需要 uniform？

有人会问：为啥不用顶点着色器直接算？
答案是：**顶点着色器是点级别，片元着色器是像素级别**。如果你要做“整块三角形一起呼吸”的效果，就得在片元阶段用 `uniform` 控制，否则每个点自己呼吸，就乱套了。

---

### 5. 小实验（你可以试试看）

* 如果把 `pulse` 去掉，直接写：

  ```glsl
  FragColor = vec4(vColor, 1.0);
  ```

  你会得到一个静态渐变三角形，没有呼吸效果。

* 如果把 `abs` 去掉：

  ```glsl
  float pulse = sin(u_time);
  ```

  那么颜色会在 \[-1, 1] 区间震荡，一半时间会变成负值，结果可能闪得刺眼（黑屏/反色）。
